from django.db import models
from django.contrib.auth.models import User
from .enumerations import SensorType, AnomalyType, SeverityLevel, AgentConfidence


# -------------------------------------------------
# 1. FARM PROFILE
# -------------------------------------------------
class FarmProfile(models.Model):
    owner = models.ForeignKey(User, on_delete=models.CASCADE, related_name="farms")
    location = models.CharField(max_length=200)
    size = models.FloatField(help_text="Farm size in hectares")
    crop_type = models.CharField(max_length=100)

    class Meta:
        db_table = "farm_profiles"
        ordering = ["owner__username"]
        indexes = [
            models.Index(fields=["owner"]),
            models.Index(fields=["location"]),
        ]

    def __str__(self):
        return f"{self.owner.username}'s Farm – {self.location}"


# -------------------------------------------------
# 2. FIELD PLOT
# -------------------------------------------------
class FieldPlot(models.Model):
    farm = models.ForeignKey(FarmProfile, on_delete=models.CASCADE, related_name="plots")
    name = models.CharField(max_length=100)
    crop_variety = models.CharField(max_length=100)

    class Meta:
        db_table = "field_plots"
        ordering = ["farm", "name"]
        indexes = [
            models.Index(fields=["farm"]),
            models.Index(fields=["name"]),
        ]

    def __str__(self):
        return f"{self.name} – {self.crop_variety}"


# -------------------------------------------------
# 3. SENSOR READING
# -------------------------------------------------
class SensorReading(models.Model):
    """
    Represents a single reading from a sensor at a specific time.
    """
    timestamp = models.DateTimeField(auto_now_add=True)  # Real server time (for logging)
    simulated_time = models.DateTimeField()  # Simulated time (e.g., 2025-01-01 06:00:00 + increments)
    plot = models.ForeignKey(FieldPlot, on_delete=models.CASCADE, related_name="readings")
    sensor_type = models.CharField(max_length=20, choices=SensorType.choices)
    value = models.FloatField()
    source = models.CharField(max_length=100, default="sensor")

    class Meta:
        db_table = "sensor_readings"
        ordering = ["-simulated_time"]  # Order by simulated time for realism
        indexes = [
            models.Index(fields=["plot"]),
            models.Index(fields=["sensor_type"]),
            models.Index(fields=["simulated_time"]),  # New index for faster queries on simulated time
        ]

    def __str__(self):
        return f"{self.sensor_type} = {self.value} on {self.simulated_time}"

# -------------------------------------------------
# 4. ANOMALY EVENT
# -------------------------------------------------
class AnomalyEvent(models.Model):
    """
    Logs an anomaly detected by the system.
    """
    timestamp = models.DateTimeField(auto_now_add=True)  # Real server time the anomaly was detected (for logging)
    simulated_time = models.DateTimeField()  # Simulated time of detection (derived from related SensorReading)
    plot = models.ForeignKey(FieldPlot, on_delete=models.CASCADE, related_name="anomalies")
    anomaly_type = models.CharField(max_length=50, choices=AnomalyType.choices)
    severity = models.CharField(max_length=10, choices=SeverityLevel.choices)
    model_confidence = models.FloatField(help_text="0 to 1")

    class Meta:
        db_table = "anomaly_events"
        ordering = ["-simulated_time"]  # Order by simulated time for dashboard readability
        indexes = [
            models.Index(fields=["plot"]),
            models.Index(fields=["anomaly_type"]),
            models.Index(fields=["severity"]),
            models.Index(fields=["simulated_time"]),  # For faster queries on simulated time
        ]

    def __str__(self):
        return f"{self.anomaly_type} ({self.severity}) at {self.simulated_time}"


# -------------------------------------------------
# 5. AGENT RECOMMENDATION
# -------------------------------------------------
class AgentRecommendation(models.Model):
    """
    Stores recommendations generated by the AI agent based on anomalies.
    """
    timestamp = models.DateTimeField(auto_now_add=True)  # Real server time (for logging)
    simulated_time = models.DateTimeField()  # Simulated time of recommendation (derived from AnomalyEvent)
    anomaly_event = models.OneToOneField(
        AnomalyEvent, on_delete=models.CASCADE, related_name="recommendation"
    )
    recommended_action = models.CharField(max_length=255)
    explanation_text = models.TextField()
    confidence = models.CharField(max_length=10, choices=AgentConfidence.choices)

    class Meta:
        db_table = "agent_recommendations"
        ordering = ["-simulated_time"]  # Order by simulated time
        indexes = [
            models.Index(fields=["anomaly_event"]),
            models.Index(fields=["simulated_time"]), 
        ]

    def __str__(self):
        return f"Action: {self.recommended_action} at {self.simulated_time}"
